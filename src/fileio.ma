	.TITLE	FILEIO
	.VERSION	18.
/
/	FILEIO Y1.8
/
/	(c) 1988, 1989, 1991 BY JOHNNY BILLQUIST
/	ALL RIGHTS RESERVED
/
/ FILEIO IS A FILE I/O PACKAGE FOR OS/8
/ IT CONSISTS OF THE FOLLOWING ROUTINES:
/
/	#	FUNCTION	DESCRIPTION
/
/	1	LOOKUP	-	DIRECTORY LOOKUP
/	2	IOPEN	-	OPEN FILE FOR INPUT
/	3	OOPEN	-	OPEN FILE FOR OUTPUT
/	4	PUT	-	PUT BLOCK IN FILE
/	5	GET	-	GET BLOCK FROM FILE
/	6	OCHAR	-	OUTPUT CHAR TO FILE
/	7	ICHAR	-	INPUT CHAR FROM FILE
/	10	PRINT	-	PRINT STRING
/	11	POSIT	-	POSITIONING OF THE FILE POINTER
/	12	POSITP	-	POSITION OF THE FILE POINTER
/	13	CLOSE	-	CLOSE FILE
/	14	FLUSH	-	FLUSH OUTPUT BUFFER
/
/ NOTE: A STRING IS A SIXBIT STRING DELIMITED BY A NULL.
/		@ IS CONTROL QUOTE.
/
/ ALL FUNCTIONS ARE CALLED IN THE FORMAT:
/
/	TAD	VAL	(OPTIONAL)
/	CIF	FILEIO
/	JMS	FILEIO
/	<FUNCTION>
/	<ARG>		(NOT ALWAYS)
/	ERROR RETURN
/	NORMAL RETURN
/
/ The appropriate File Block must have been copied into
/ THEFIB before calling FILEIO.
/
	.XSECT	.FIOX
	FIELD	2
X0,	0
X1,	0

	.ZSECT	.FIOZ
	FIELD	2
	.GLOBAL THEFIB
THEFIB,	ZBLOCK	20,0
ARG,	0
LC,	0
TMP,	0
AC,	0
FUNC,	0
FILEBL,	0

	.RSECT	.FILIO
	.ENTRY	$FILEIO
	FIELD	2
	.EXTERNAL SBFILE, SBDEV

	USR=7700
/ FIle Info Block fields:
	DEVADR=00	/ Device handler entry
	DEVNUM=01	/ OS8 Device number
	BUFADR=02	/ Buffer address
	BUFFLD=03	/ Buffer field
	FILLIN=04	/ spare
	BUFCNT=05	/ Buffer count
	FILBLK=06	/ File pointer
	FILFLG=07	/ Flags
	FILBEG=10	/ First block in file
	FILSIZ=11	/ Number of blocks in file
	FILEND=12	/ Last block in file
	FILNAM=13	/ File name in SIXBIT
	FILEXT=16	/ FIle extension in SIXBIT
	FILDAT=17	/ Date

/ Flag word layout:
/	+-+-+-+-+-+-+-+-+-+-+-+-+
/	! ! ! ! ! ! ! ! ! ! ! ! !
/	+-+-+-+-+-+-+-+-+-+-+-+-+
/	 ! !                   +- TENTATIVE
/	 ! +--------------------- FILE OPEN
/	 +----------------------- MODIFIED
	.SBTTL	MAIN
/
/	M A I N   B O D Y
/
$FILEIO,
	0		/ENTRY TO FILEIO.
	DCA	AC	/SAVE AC
	TAD I	$FILEIO	/GET FUNCTION
	DCA	FUNC
	ISZ	$FILEIO
	TAD I	$FILEIO	/GET ARG
	DCA	ARG

	/ Check for device driver.
	TAD	THEFIB+DEVADR
	SZA CLA
	JMP	DOIT	/ Loaded, ok to dispatch
	CMA		/ Not loaded, fatal error.
	JMP	ERR1

DOIT,	TAD	FUNC	/GET FUNCTION CODE.
	SPA SNA		/IS IT >0?
	JMP	FERR	/NO. FUNCTION ERROR.
	TAD	(-MAXFUN	/IS IT >MAXFUN?
	SMA
	JMP	FERR	/YES. FUNCTION ERROR.

	/ Does the function require an open file?
	TAD	(MAXFUN-NOPFUN
	SPA CLA
	JMP	NOTFUN	/NO.

	TAD	THEFIB+FILFLG	/GET FLAGS.
	RTL
	SNL CLA		/IS FILE OPEN?
	JMP	ERR1	/NO. OPEN ERROR.
NOTFUN,	TAD	FUNC	/ Get function again
	CLL RAL		/MULTIPLY FUNCTION BY 2.
	TAD	DODISP	/ADD ADDRESS OF TABLE.
	DCA	TMP	/SAVE POINTER INTO TABLE.
	TAD I	TMP	/ Get 1st word (ARGUSE)
	SZA CLA		/DOES THIS FUNCTION USE ARG?
	ISZ	$FILEIO	/YES. BUMP RETURN ADDRESS.
	ISZ	TMP	/POINT TO NEXT WORD (FUNC ADDRESS)
	TAD I	TMP	/GET ADDRESS.
	DCA	TMP	/SAVE IT.
	JMS I	TMP	/JUMP TO IT.

XIT1,	ISZ	$FILEIO	/NORMAL EXIT. BUMP RETURN ADDRESS
	SKP CLA		/SKIP ERROR ENTRY.
ERR1,	DCA	AC	/ERROR ENTRY. SAVE ERROR CODE.
	/ Restore AC and return
	TAD	AC
	JMP I	$FILEIO

FERR,	CIF	10
	JMS	USR	/FUNCTION ERROR. USER ERROR 11.
	7
	11
/
DODISP,	DODISP;0	/DISPATCH TABLE
	-1;LOOK1
	-1;IOPEN1
	-1;OOPEN1
	NOPFUN=.-DODISP%2
	0;PUT1
	0;GET1
	0;OCHAR1
	0;ICHAR1
	-1;0	/ Unused PRINT1
	-1;POSIT1
	-1;POSIP1
	0;CLOSE1
	0;FLUSH1
/
	MAXFUN=.-DODISP%2
/
	PAGE
	.SBTTL	LOOKUP
/
/	1	LOOKUP
/
/	AC		FILE SEQUENCE #
/	FILEBLOCK	TO BE FILLED WITH CORRECT DATA
/	ARG		POINTER TO FILE NAME
/
/	ERROR:
/	AC	>0	HOW MANY NOT FOUND. FILE NOT FOUND
/		=0	NONFATAL DEVICE ERROR.
/		<0	FATAL DEVICE ERROR.
/
LOOK1,	0
	JMP I LOOK1	/ Unused in FORTH
	PAGE
	.SBTTL	IOPEN
/
/	2	IOPEN
/
/	ARG		FILENAME
/
/	ERROR:
/	AC	>=0	FILE NOT FOUND. NEW FILE CREATED.
/		<0	FATAL DEVICE ERROR
/
IOPEN1,	0
	TAD (SBFILE)
	DCA 1$
	TAD	THEFIB+DEVNUM	/GET DEVICE #
	CIF	10
	JMS	USR	/CALL USR
	2		/LOOKUP
1$:	SBFILE		/ PARSE puts name here
2$:	0
	JMP	ERRP

	TAD	(THEFIB+FILLIN	/SET UP POINTER TO FILEBLOCK
	DCA	X0

	TAD	(1000)
	DCA I	X0	/SET BUFFER COUNT
	DCA I	X0	/SET FILE POINTER
	TAD	(2000
	DCA I	X0	/SET FILE FLAGS
	TAD	1$
	DCA I	X0	/SET FILE ADDRESS
	TAD	2$
	CIA
	DCA I	X0	/SET FILE SIZE
	TAD	THEFIB+FILSIZ
	TAD	THEFIB+FILBEG
	DCA I	X0	/SET FILE END
	TAD	(SBFILE-1) / Save name in FIB
	DCA	X1
	TAD	(-4)	/ Name + ext
	DCA	LC
4$:	TAD I	X1
	DCA I	X0
	ISZ	LC
	JMP	4$
	JMP I	IOPEN1

ERRP,/	CLA
/	JMS	OOP2	/NO FILE FOUND. TEST TO OPEN OUTPUT.
/	CLA IAC		/AC=1
	JMP	ERR1	/ERROR RETURN. 1 MEANS FILE CREATED.

	.SBTTL	OOPEN

/	3	OOPEN
/
/	AC		MAX SIZE IN BLOCKS OF FILE
/
/	ERROR:
/	AC	>=0	NONFATAL ERROR
/		<0	FATAL ERROR
/
OOPEN1,	0
	TAD (SBFILE)
	DCA 1$
	TAD	AC	/GET MAX SIZE REQUESTED
	RTL;RTL
	AND	(7760
	TAD	THEFIB+DEVNUM	/COMBINED WITH DEVICE #
	CIF	10
	JMS	USR	/CALL USR
	3		/ENTER
1$:	SBFILE		/ Parse puts name here
2$:	0
	JMP	ERR1

	TAD	(THEFIB+FILLIN	/SET UP POINTER TO FILEBLOCK
	DCA	X0

	TAD	(1000)
	DCA I	X0	/SET BUFFER COUNT
	DCA I	X0	/SET FILE POINTER
	TAD	(2001
	DCA I	X0	/SET FILE FLAGS
	TAD	1$
	DCA I	X0	/SET FILE ADDRESS
	DCA I	X0	/SET FILE SIZE
	TAD	2$
	CIA
	TAD	1$
	DCA I	X0	/SET FILE END
	TAD	(FILE-1)
	DCA	X1
	TAD	(-4)
	DCA	LC
4$:	TAD I	X1
	DCA I	X0
	ISZ	LC
	JMP	4$
	TAD	7666
	DCA I	X0	/SET FILE DATE
	JMP I	OOPEN1
/
FNAM,	ZBLOCK	10
FILE,	ZBLOCK	10
/
	PAGE
	.SBTTL	PUT
/
/	4	PUT
/
/	AC		RELATIVE BLOCK #
/
/	ERROR:
/	AC	>=0	NO MORE SPACE
/	AC	<0	FATAL DEVICE ERROR
/
PUT1,	0
	ISZ	THEFIB+FILBLK	/BUMP LAST.
	TAD	AC	/GET REQUESTED BLOCK.
	SZA		/ZERO?
	DCA	THEFIB+FILBLK	/NO. SAVE AS DEFAULT.
	CMA
	TAD	THEFIB+FILBLK	/GET THEFIB TO WRITE.
	TAD	THEFIB+FILBEG
	DCA	OBLK	/SAVE AS BLOCK TO OUTPUT TO.
	TAD	THEFIB+FILEND	/GET FILE END POINTER...
	CIA
	CLL CML
	TAD	OBLK	/COMPARE WITH FILE PTR...
	SNL CLA		/L=0 PTR OUT OF FILE SPACE.
	JMP	ERR1	/YES. ERROR!
	TAD	THEFIB+BUFADR	/NO. GET BLOCK ADDRESS
	DCA	OADR	/SAVE AS ADDRESS TO OUTPUT FROM.
	TAD	THEFIB+BUFFLD	/GET FIELD
	TAD	(4200	/COMBINE WITH WRITE 1 BLOCK CODE.
	DCA	OFUN	/SAVE AS FUNCTION.
	CIF		/CALL DEVICE DRIVER WITH THIS INFO.
	JMS I	THEFIB+DEVADR
OFUN,	0
OADR,	0
OBLK,	0
	JMP	ERR1	/DEVICE ERROR.

	TAD	THEFIB+FILFLG	/CLEAR MODIFIED FLAG.
	AND	(3777
	DCA	THEFIB+FILFLG
	TAD	THEFIB+FILBLK	/GET WRITTEN BLOCK.
	CIA CLL CML
	TAD	THEFIB+FILSIZ	/COMPARE WITH SIZE.
	SNL		/SIZE GROW?
	JMP	1$	/NO.
	CIA		/YES. ADD CHANGE.
	TAD	THEFIB+FILSIZ
	DCA	THEFIB+FILSIZ	/SAVE AS NEW SIZE.

1$:	CLA
	TAD	THEFIB+FILBLK	/GET AC.
	DCA	AC	/SAVE BLOCK OPERATED FROM.

	JMP I	PUT1	/RETURN
	.SBTTL	GET
/
/	5	GET
/
/	AC		RELATIVE BLOCK #
/
/	ERROR:
/	AC	>=0	END OF FILE
/	AC	<0	FATAL DEVICE ERROR
/
GET1,	0
	TAD	THEFIB+FILFLG	/GET FLAGS
	SMA CLA		/MODIFIED BIT SET?
	JMP	1$	/NO.
	TAD	AC	/YES. SAVE AC.
	DCA	ACS
	TAD	THEFIB+FILBLK	/SET UP FOR PUT TO OLD BLOCK.
	DCA	AC
	JMS	PUT1	/PUT BLOCK
	TAD	ACS	/RESTORE AC
	DCA	AC

1$:	TAD	AC	/CHECK IF BLOCK ALREADY IN MEMORY...
	SNA
	JMP	2$	/BLOCK ZERO DOESN'T COUNT...
	CIA
	TAD	THEFIB+FILBLK
	SNA CLA
	JMP I	GET1	/ALREADY IN MEMORY. DON'T READ IT!

2$:	ISZ	THEFIB+FILBLK	/BUMP DEFAULT.
	TAD	AC	/GET AC.
	SZA		/ZERO?
	DCA	THEFIB+FILBLK	/NO. SAVE AS DEAFULT.

	CMA		/NO. CALCULATE ABSOLUTE ADDRESS.
	TAD	THEFIB+FILBLK
	TAD	THEFIB+FILBEG
	DCA	IBLK	/SAVE IT.
	TAD	THEFIB+FILEND	/GET FILE END PTR.
	CIA
	CLL CML
	TAD	IBLK	/COMPARE WITH FILE PTR.
	SNL CLA		/L=0 MEANS OUT OF FILE BOUNDS. ERROR!
	JMP	ERR1	/YES. ERROR.
	TAD	THEFIB+BUFADR
	DCA	IADR	/TRANSFER ADDRESS...
	TAD	THEFIB+BUFFLD	/GET FIELD...
	TAD	(200	/... AND COMBINE WITH READ 1 BLOCK...
	DCA	IFUN	/... AND SAVE AS FUNCTION.

	CIF		/CALL DEVICE DRIVER.
	JMS I	THEFIB+DEVADR
IFUN,	0
IADR,	0
IBLK,	0
	JMP	ERR1

	JMP I	GET1	/RETURN

ACS,	0

// Get next sequential block in a file.
// ICHAR and OCHAR call this as required.
NXTBLK,	0
	CLA
	TAD THEFIB+FILBLK	/GET LAST BLOCK.
	DCA AC	/SAVE AS AC FOR PUT ROUTINE.
	TAD THEFIB+FILFLG	/BUFFER MODIFIED?
	SPA CLA
	JMS PUT1	/PUT BLOCK.
	ISZ AC		/SET AC TO READ BLOCK
	TAD THEFIB+FILEND /GET END PTR.
	CIA
	CLL CML
	TAD AC		/GET BLOCK TO READ.
	TAD THEFIB+FILBEG	/ADD ADDRESS.
	SNL SZA CLA	/ADDRESS > END?
	JMP ERR1	/YES. ERROR. NO MORE SPACE!

	CMA
	TAD AC	/GET PTR.
	CIA CLL CML
	TAD THEFIB+FILSIZ	/COMPARE WITH SIZE.
	SNL SZA
	ISZ NXTBLK	/PTR <= SIZE. BUMP RETURN. READ DONE.
	SNL SZA CLA	/PTR > SIZE?
	JMS GET1	/NO. READ BLOCK.
	DCA THEFIB+BUFCNT /CLEAR OFFSET.
	TAD AC		/GET CURRENT BLOCK.
	DCA THEFIB+FILBLK /SAVE CURRENT BLOCK.

	JMP I	NXTBLK	/RETURN
/
	PAGE
	.SBTTL	OCHAR
/
/ 6	OCHAR
/
/ AC	CHARACTER
/
/ ERROR:
/	AC	>=0	NO MORE SPACE
/	AC	<0	FATAL DEVICE ERROR
/
ICHAR,
OCHAR1,	0
	TAD	AC	/GET CHARACTER
	DCA	OCHAR	/SAVE IT.

	TAD	THEFIB+BUFCNT	/GET OFFSET.
	TAD	(-1000)		/CHECK IF END OF BLOCK REACHED.
	SZA CLA
	JMP	1$		/NO.
	JMS	NXTBLK	/YES. NEXT BLOCK.
	NOP

1$:	TAD	THEFIB+BUFCNT	/GET COUNT
	AND	(1774)
	CLL RAR
	TAD	THEFIB+BUFADR
	DCA	ARG		/THIS IS POINTER TO DOUBLEWORD CONTANING CHAR
	TAD	THEFIB+BUFFLD	/MAKE FIELD CHANGE CODE.
	TAD	(CDF)
	DCA	.+1
	HLT			/CHANGE FIELD.
	TAD	THEFIB+BUFCNT
	AND	(3)
	TAD	(-1)
	SNA		/0 = 2:ND CHAR...
	ISZ	ARG	/2:ND CHAR IS IN 2:ND WORD.
	SMA SZA CLA	/3:RD CHAR?
	JMP	OSPLIT	/3:RD...

	TAD I	ARG	/GET WORD.
	AND	(7400	/MASK CHAR.
	TAD	OCHAR	/PUT IN NEW CHAR.
	DCA I	ARG	/RESTORE.
OCRET,	CDF	.	/RESTORE FIELD.
	ISZ	THEFIB+BUFCNT	/BUMP POINTER.
	TAD	THEFIB+FILFLG	/SET BUFFER MODIFIED BIT.
	RAL
	CLL CML RAR
	DCA	THEFIB+FILFLG
	TAD	THEFIB+BUFCNT	/CHECK IF BUFFER IS FULL.
	TAD	(-1000)
	SZA CLA
	JMP	1$		/IS NOT.
	TAD	THEFIB+FILBLK	/IT IS. GET CURRENT BLOCK.
	DCA	AC
	JMS	PUT1		/OUTPUT CURRENT BLOCK

1$:	TAD	OCHAR		/GIVE OUTPUT CHARACTER BACK.
	DCA	AC
	JMP I	OCHAR1

OSPLIT,	CLA CLL CMA RAL	/REPEAT LOOP TWICE.
	DCA	LC
	TAD	OCHAR	/GET CHAR.
	RTL;RTL		/GET HIGH PART.
1$:	AND	(7400	/MASK.
	DCA	TMP	/SAVE IT.
	TAD I	ARG	/GET 1:ST WORD.
	AND	(377	/MASK AWAY PREVIOUS CHAR.
	TAD	TMP	/SAVE NEW CHAR.
	DCA I	ARG	/SAVE WORD.
	ISZ	ARG	/POINT AT NEXT WORD.
	TAD	OCHAR	/GET CHAR.
	RTR;RTR;RAR	/GET LOW PART
	ISZ	LC	/LOOP.
	JMP	1$
	CLA
	ISZ	THEFIB+BUFCNT
	JMP	OCRET	/CONTINUE.
	.SBTTL	ICHAR
/
/ 7	ICHAR
/
/ AC	The read character
/
/ ERROR:
/	AC	>=0	END OF FILE
/	AC	<0	FATAL DEVICE ERROR
OCHAR,
ICHAR1,	0
	TAD THEFIB+BUFCNT	/CHECK BUFFER COUNT.
	TAD (-1000)		/END?
	SZA CLA
	JMP 1$		/NO.
	JMS NXTBLK		/YES.
	JMP ERR1	/NO READ DONE. EOF.

1$:	TAD THEFIB+BUFCNT	/GET BUFFER COUNT.
	AND (1774)
	CLL RAR
	TAD THEFIB+BUFADR
	/ Save. First of two words of 3 chars.
	DCA ARG
	TAD THEFIB+BUFCNT
	AND (3)
	TAD (-1)
	SNA
	ISZ ARG
	SMA SZA CLA
	JMP ISPLIT	/ Go do third char
	TAD I ARG	/GET WORD.
	AND (377)	/ Mask 8 bit byte
PRET,	ISZ THEFIB+BUFCNT
	DCA AC	/SAVE CHAR.
	JMP I ICHAR1	/RETURN.

	/ Back up for 3rd of 3 chars.
ISPLIT,	TAD I ARG	/ High part in 1st word
	AND (7400	/MASK
	CLL RTR;RTR	/MOVE TO PLACE.
	DCA TMP		/SAVE.
	ISZ ARG
	TAD I ARG	/ Low part in 2nd word
	AND (7400	/MASK
	CLL RTL;RTL;RAL	/ Move thru link
	TAD TMP		/ Merge saved hi part
	ISZ THEFIB+BUFCNT
	JMP PRET	/CONTINUE.

	PAGE
	.SBTTL	POSIT
/ 11	POSIT
/
/ ARG	POINTER TO POSITION (24BIT)
/
/ ERROR:
/	AC	>=0	END OF FILE
/		<0	FATAL DEVICE ERROR
/
POSIT1,	0
	TAD I	ARG	/GET ADDRESS OF ARGUMENT.
	DCA	TMP
	TAD I	TMP	/GET BLOCK #.
	ISZ	TMP
	DCA	AC
	TAD I	TMP	/GET OFFSET.
	DCA	THEFIB+BUFCNT
	CDF	.
	JMS	GET1	/READ IN BLOCK.
	JMP I	POSIT1	/RETURN
	.SBTTL	POSITP
/
/ 12	POSITP
/
/ AC	RETURNED LOW PART OF POS.
/ ARG	POINTER TO ADDRESS FOR HIGH PART.
/
/	ERROR:
/	NONE

POSIP1,	0
	TAD I	ARG	/GET POINTER TO RESULT ADDRESS.
	DCA	TMP
	TAD	THEFIB+FILBLK	/GET BLOCK.
	DCA I	TMP
	ISZ	TMP
	TAD	THEFIB+BUFCNT	/GET OFFSET.
	DCA I	TMP
	CDF	.
	JMP I	POSIP1	/RETURN
	.SBTTL	CLOSE
/
/ 13	CLOSE
/
/ ERROR:
/	AC	>=0	NO MORE SPACE
/		<0	FATAL DEVICE ERROR

CLOSE1,	0
	TAD	THEFIB+FILFLG	/GET FLAGS.
	SMA CLA		/MODIFIED BLOCK?
	JMP	1$	/NO.
	TAD	THEFIB+FILBLK	/YES. OUTPUT IT.
	DCA	AC
	JMS	PUT1

1$:	TAD	THEFIB+FILFLG	/GET FLAGS.
	RAR
	SNL CLA		/TENTATIVE FILE?
	JMP	ECLOSE	/NO.

	TAD	(THEFIB+FILNAM-1)
	DCA	X0
	TAD	(FILE-1)
	DCA	X1
	TAD	(-4)
	DCA	LC
2$:	TAD I	X0
	DCA I	X1
	ISZ	LC
	JMP	2$

	TAD	THEFIB+FILSIZ	/YES. SET UP FINAL SIZE.
	DCA	FSIZ

	TAD	THEFIB+DEVNUM	/GET DEV. #
	CIF	10
	JMS	USR	/CALL USR FOR CLOSE.
	4
	FILE
FSIZ,	0
	JMP	ERR1

ECLOSE,	DCA	THEFIB+FILFLG	/CLEAR FILE FLAGS.
	JMP I	CLOSE1	/RETURN
/
	PAGE
	.SBTTL	FLUSH
/
/	14	FLUSH
/
/	OUTPUT:
/	AC		BLOCK #
/
/	ERROR:
/	AC	>=0	NO MORE SPACE
/		<0	FATAL DEVICE ERROR
/
FLUSH1,	0		/ENTRY TO FLUSH.
	DCA	AC	/CLEAR AC.
	TAD	THEFIB+FILFLG	/CHECK IF BLOCK HAS BEEN MODIFIED.
	SMA CLA
	JMP I	FLUSH1		/WAS NOT...

1$:	TAD	THEFIB+BUFCNT	/FILL REST OF CURRENT WORD...
	AND	(3)		/GET BYTE OFFSET.
	SNA CLA			/OFFSET=0?
	JMP	2$		/YES.
	JMS	OCHAR1		/NO. OUTPUT A NUL.
	JMP	1$		/REPEAT.

2$:	TAD	THEFIB+BUFCNT	/GET OFFSET.
	AND	(1774)		/GET WORD OFFSET.
	CLL RAR
	DCA	TMP		/SAVE OFFSET.
	TAD	TMP
	TAD	(-400)		/GET COUNT.
	SNA
	JMP	4$		/ALREADY AT END OF BLOCK.
	DCA	LC
	TAD	TMP		/GET OFFSET.
	TAD	THEFIB+BUFADR
	DCA	TMP		/SAVE ADDRESS.
	TAD	THEFIB+BUFFLD	/GET BUFFER FIELD.
	TAD	(CDF)
	DCA	.+1
	HLT			/CHANGE FIELD.

3$:	DCA I	TMP		/CLEAR WORD.
	ISZ	TMP		/BUMP POINTER.
	ISZ	LC		/BUMP COUNTER.
	JMP	3$		/LOOP.

4$:	CDF	.		/CHANGE FIELD BACK.
	TAD	(1000)		/SET POINTER TO END OF BLOCK.
	DCA	THEFIB+BUFCNT
	TAD	THEFIB+FILBLK	/GET CURRENT BLOCK #.
	DCA	AC
	JMS	PUT1		/OUTPUT CURRENT BLOCK #.

	JMP I	FLUSH1

