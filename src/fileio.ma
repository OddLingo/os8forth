	.TITLE	FILEIO
	.VERSION	18.
/
/	FILEIO Y1.8
/
/	(c) 1988, 1989, 1991 BY JOHNNY BILLQUIST
/	ALL RIGHTS RESERVED
/
/ FILEIO IS A FILE I/O PACKAGE FOR OS/8
/ IT CONSISTS OF THE FOLLOWING ROUTINES:
/
/	#	FUNCTION	DESCRIPTION
/
/	1	LOOKUP	-	DIRECTORY LOOKUP
/	2	IOPEN	-	OPEN FILE FOR INPUT
/	3	OOPEN	-	OPEN FILE FOR OUTPUT
/	4	PUT	-	PUT BLOCK IN FILE
/	5	GET	-	GET BLOCK FROM FILE
/	6	OCHAR	-	OUTPUT CHAR TO FILE
/	7	ICHAR	-	INPUT CHAR FROM FILE
/	10	PRINT	-	PRINT STRING
/	11	POSIT	-	POSITIONING OF THE FILE POINTER
/	12	POSITP	-	POSITION OF THE FILE POINTER
/	13	CLOSE	-	CLOSE FILE
/	14	FLUSH	-	FLUSH OUTPUT BUFFER
/
/ NOTE: A STRING IS A SIXBIT STRING DELIMITED BY A NULL.
/		@ IS CONTROL QUOTE.
/
/ ALL FUNCTIONS ARE CALLED IN THE FORMAT:
/
/	TAD	VAL	(OPTIONAL)
/	CIF	FILEIO
/	JMS	FILEIO
/	<FUNCTION>
/	<ARG>		(NOT ALWAYS)
/	ERROR RETURN
/	NORMAL RETURN
/
/ The appropriate File Block must have been copied into
/ THEFIB before calling FILEIO.
/
	.XSECT	.FIOX
	FIELD	2
X0,	0
X1,	0

	.ZSECT	.FIOZ
	FIELD	2
	.GLOBAL THEFIB
THEFIB,	ZBLOCK	20,0	/ Active file information
ARG,	0		/ Copy of input arg
LC,	0		/ Loop counter
TMP,	0
AC,	0		/ In-out AC value
FUNC,	0		/ Function code

	.RSECT	.FILIO
	.ENTRY	$FILEIO
	FIELD	2
	.EXTERNAL SBFILE, SBDEV

	USR=7700
	/ File Info Block layout
	DEVADR=00	/ Device handler entry
	DEVNUM=01	/ OS8 Device number
	BUFADR=02	/ Buffer address
	BUFFLD=03	/ Buffer field
	FILLIN=04	/ spare
	BUFPOS=05	/ Position within buffer
	FILBLK=06	/ File pointer
	FILFLG=07	/ Flags
	FILBEG=10	/ First block in file
	FILSIZ=11	/ Number of blocks in file
	FILEND=12	/ Last block in file
	FILNAM=13	/ File name in SIXBIT
	FILEXT=16	/ FIle extension in SIXBIT
	FILDAT=17	/ Date

/ Flag word layout:
/	+-+-+-+-+-+-+-+-+-+-+-+-+
/	! ! ! ! ! ! ! ! ! ! ! ! !
/	+-+-+-+-+-+-+-+-+-+-+-+-+
/	 ! !                   +- TENTATIVE
/	 ! +--------------------- FILE OPEN
/	 +----------------------- MODIFIED
	.SBTTL	MAIN
/
/	M A I N   B O D Y
/
$FILEIO,
	0		/ENTRY TO FILEIO.
	DCA AC	/SAVE AC
	TAD I $FILEIO	/GET FUNCTION
	DCA FUNC	/Save it
	ISZ $FILEIO
	TAD I $FILEIO	/GET ARG
	DCA ARG

	/ Check for device driver.
	TAD	THEFIB+DEVADR
	SZA CLA
	JMP	DOIT	/ Loaded, ok to dispatch
	CMA		/ Not loaded, fatal error.
	JMP	ERR1

DOIT,	TAD	FUNC	/GET FUNCTION CODE.
	SPA SNA		/IS IT >0?
	JMP	FERR	/NO. FUNCTION ERROR.
	TAD	(-MAXFUN	/IS IT >MAXFUN?
	SMA
	JMP	FERR	/YES. FUNCTION ERROR.

	/ Does the function require an open file?
	TAD	(MAXFUN-NOPFUN
	SPA CLA
	JMP	NOTFUN	/NO.

	TAD	THEFIB+FILFLG	/GET FLAGS.
	RTL
	SNL CLA		/IS FILE OPEN?
	JMP	ERR1	/NO. OPEN ERROR.
NOTFUN,	TAD	FUNC	/ Get function again
	CLL RAL		/MULTIPLY FUNCTION BY 2.
	TAD	DODISP	/ADD ADDRESS OF TABLE.
	DCA	TMP	/SAVE POINTER INTO TABLE.
	TAD I	TMP	/ Get 1st word (ARGUSE)
	SZA CLA		/DOES THIS FUNCTION USE ARG?
	ISZ	$FILEIO	/YES. BUMP RETURN ADDRESS.
	ISZ	TMP	/POINT TO NEXT WORD (FUNC ADDRESS)
	TAD I	TMP	/GET ADDRESS.
	DCA	TMP	/SAVE IT.
	JMS I	TMP	/JUMP TO IT.

XIT1,	ISZ	$FILEIO	/NORMAL EXIT. BUMP RETURN ADDRESS
	SKP CLA		/SKIP ERROR ENTRY.
ERR1,	DCA	AC	/ERROR ENTRY. SAVE ERROR CODE.
	/ Restore AC and return
	TAD	AC
	JMP I	$FILEIO

FERR,	CIF	10
	JMS	USR	/FUNCTION ERROR. USER ERROR 11.
	7
	11

/ The dispatch tabhle has two words for each function.
/ The first word is non-zero if the function needs
/ an open file.  The second word is the entry address.
DODISP,	DODISP;0
	-1;0 / LOOK1
	-1;IOPEN1
	-1;OOPEN1
	NOPFUN=.-DODISP%2
	0;PUT1
	0;GET1
	0;OCHAR1
	0;ICHAR1
	-1;0	/ Unused PRINT1
	-1;POSIT1
	-1;POSIP1
	0;CLOSE1
	0;FLUSH1
/
	MAXFUN=.-DODISP%2

	.SBTTL	IOPEN

/
/ 2	IOPEN
/
/ ARG	Address of filename in parsed SIXBIT
/
/ ERROR:
/	AC	>=0	FILE NOT FOUND. NEW FILE CREATED.
/		<0	FATAL DEVICE ERROR
IOPEN1,	0
	TAD (SBFILE)
	DCA 1$
	TAD THEFIB+DEVNUM	/GET DEVICE #
	CIF 10
	JMS USR	/CALL USR
	2		/LOOKUP
1$:	SBFILE		/ PARSE puts name here
2$:	0
	JMP	ERRP

	TAD (THEFIB+FILLIN	/SET UP POINTER TO FILEBLOCK
	DCA X0

	TAD (1000)
	DCA I	X0	/SET BUFFER COUNT
	DCA I	X0	/SET FILE POINTER
	TAD (2000
	DCA I	X0	/SET FILE FLAGS
	TAD	1$
	DCA I	X0	/SET FILE ADDRESS
	TAD	2$
	CIA
	DCA I	X0	/SET FILE SIZE
	TAD	THEFIB+FILSIZ
	TAD	THEFIB+FILBEG
	DCA I	X0	/SET FILE END
	TAD	(SBFILE-1) / Save name in FIB
	DCA	X1
	TAD	(-4)	/ Name + ext
	DCA	LC
4$:	TAD I	X1
	DCA I	X0
	ISZ	LC
	JMP	4$
	JMP I	IOPEN1

ERRP,/	CLA
/	JMS	OOP2	/NO FILE FOUND. TEST TO OPEN OUTPUT.
/	CLA IAC		/AC=1
	JMP	ERR1	/ERROR RETURN. 1 MEANS FILE CREATED.

	PAGE
	.SBTTL	OOPEN

/ 3	OOPEN
/
/ AC	MAX SIZE IN BLOCKS OF FILE
/
/ ERROR:
/	AC	>=0	NONFATAL ERROR
/		<0	FATAL ERROR
/
OOPEN1,	0
	TAD (SBFILE)	/ Parse puts name here
	DCA 1$
	TAD THEFIB+DEVNUM	/ Device #
	CIF	10
	JMS	USR	/CALL USR
	3		/ENTER
1$:	SBFILE		/ First output block
2$:	0		/ Neg out limit
	JMP	ERR1

	TAD (THEFIB+FILLIN	/SET UP POINTER TO FILEBLOCK
	DCA X0

	TAD (1000)
	DCA I X0	/SET BUFFER COUNT
	DCA I X0	/ File position zero
	TAD (2001)
	DCA I X0	/SET FILE FLAGS
	TAD 1$
	DCA I X0	/ Block position
	DCA I X0	/ Zero size
	TAD 2$		/ Negative max len
	CIA
	TAD 1$		/ plus start
	DCA I X0	/ gives end block.

	TAD (SBFILE-1)	/ Copy name to FIB
	DCA X1
	TAD (-4)
	DCA LC
LOOP$:	TAD I X1
	DCA I X0
	ISZ LC
	JMP LOOP$

	TAD 7666
	DCA I X0	/SET FILE DATE
	JMP I OOPEN1

	PAGE
	.SBTTL	PUT
/
/	4	PUT
/
/ AC		RELATIVE BLOCK #
/
/ ERROR:
/	AC	>=0	NO MORE SPACE
/	AC	<0	FATAL DEVICE ERROR
/
PUT1,	0
	ISZ THEFIB+FILBLK	/BUMP LAST.
	TAD AC			/GET REQUESTED BLOCK.
	SZA		/ZERO?
	DCA THEFIB+FILBLK	/NO. SAVE AS DEFAULT.
	CMA
	TAD THEFIB+FILBLK	/GET THEFIB TO WRITE.
	TAD THEFIB+FILBEG
	DCA OBLK	/SAVE AS BLOCK TO OUTPUT TO.
	TAD THEFIB+FILEND	/GET FILE END POINTER...
	CIA
	CLL CML
	TAD OBLK	/COMPARE WITH FILE PTR...
	SNL CLA		/L=0 PTR OUT OF FILE SPACE.
	JMP ERR1	/YES. ERROR!
	TAD THEFIB+BUFADR	/NO. GET BLOCK ADDRESS
	DCA OADR	/SAVE AS ADDRESS TO OUTPUT FROM.
	TAD THEFIB+BUFFLD	/GET FIELD
	TAD (4200	/COMBINE WITH WRITE 1 BLOCK CODE.
	DCA OFUN	/SAVE AS FUNCTION.
	CIF		/CALL DEVICE DRIVER WITH THIS INFO.
	JMS I THEFIB+DEVADR
OFUN,	0
OADR,	0
OBLK,	0
	JMP ERR1	/DEVICE ERROR.

	TAD THEFIB+FILFLG	/CLEAR MODIFIED FLAG.
	AND (3777
	DCA THEFIB+FILFLG
	TAD THEFIB+FILBLK	/GET WRITTEN BLOCK.
	CIA CLL CML
	TAD THEFIB+FILSIZ	/COMPARE WITH SIZE.
	SNL		/SIZE GROW?
	JMP 1$		/NO.
	CIA		/YES. ADD CHANGE.
	TAD THEFIB+FILSIZ
	DCA THEFIB+FILSIZ	/SAVE AS NEW SIZE.

1$:	CLA
	TAD THEFIB+FILBLK	/GET AC.
	DCA AC	/SAVE BLOCK OPERATED FROM.

	JMP I PUT1	/RETURN
	.SBTTL	GET
/
/	5	GET
/
/ AC		RELATIVE BLOCK #
/
/ ERROR:
/	AC	>=0	END OF FILE
/	AC	<0	FATAL DEVICE ERROR
/
GET1,	0
	TAD THEFIB+FILFLG	/GET FLAGS
	SMA CLA		/ Was old buffer modified?
	JMP 1$		/NO.

	/ Need to write out old block first.
	TAD AC		/YES. SAVE AC.
	DCA ACS
	TAD THEFIB+FILBLK / SET UP FOR PUT TO OLD BLOCK.
	DCA AC
	JMS PUT1	/PUT BLOCK
	TAD ACS		/RESTORE AC
	DCA AC

1$:	TAD AC		/CHECK IF BLOCK ALREADY IN MEMORY...
	SNA
	JMP	2$	/BLOCK ZERO DOESN'T COUNT...
	CIA
	TAD THEFIB+FILBLK
	SNA CLA
	JMP I GET1	/ALREADY IN MEMORY. DON'T READ IT!

2$:	ISZ THEFIB+FILBLK	/BUMP DEFAULT.
	TAD AC			/GET AC.
	SZA		/ZERO?
	DCA THEFIB+FILBLK	/NO. SAVE AS DEAFULT.

	CMA		/NO. CALCULATE ABSOLUTE ADDRESS.
	TAD THEFIB+FILBLK    / relative block
	TAD THEFIB+FILBEG    / plus first block
	DCA IBLK	/SAVE IT.

	/ OS8 does not check file limit so we have to
	/ do it here.
	TAD THEFIB+FILEND	/GET FILE END PTR.
	CIA
	CLL CML
	TAD IBLK	/COMPARE WITH FILE PTR.
	SNL CLA		/L=0 MEANS OUT OF FILE BOUNDS. ERROR!
	JMP ERR1	/YES. ERROR.

	/ In range so proceed
	TAD THEFIB+BUFADR
	DCA IADR	/TRANSFER ADDRESS...
	TAD THEFIB+BUFFLD	/GET FIELD...
	TAD (200	/... AND COMBINE WITH READ 1 BLOCK...
	DCA IFUN	/... AND SAVE AS FUNCTION.

	CIF		/CALL DEVICE DRIVER.
	JMS I THEFIB+DEVADR
IFUN,	0
IADR,	0
IBLK,	0
	JMP ERR1

	JMP I GET1	/RETURN

ACS,	0

// Get next sequential block in a file.
// ICHAR and OCHAR call this as required.
NXTBLK,	0
	CLA
	TAD THEFIB+FILBLK	/GET LAST BLOCK.
	DCA AC	/SAVE AS AC FOR PUT ROUTINE.
	TAD THEFIB+FILFLG	/BUFFER MODIFIED?
	SPA CLA
	JMS PUT1	/PUT BLOCK.
	ISZ AC		/SET AC TO READ BLOCK
	TAD THEFIB+FILEND /GET END PTR.
	CIA
	CLL CML
	TAD AC		/GET BLOCK TO READ.
	TAD THEFIB+FILBEG	/ADD ADDRESS.
	SNL SZA CLA	/ADDRESS > END?
	JMP ERR1	/YES. ERROR. NO MORE SPACE!

	CMA
	TAD AC	/GET PTR.
	CIA CLL CML
	TAD THEFIB+FILSIZ	/COMPARE WITH SIZE.
	SNL SZA
	ISZ NXTBLK	/PTR <= SIZE. BUMP RETURN. READ DONE.
	SNL SZA CLA	/PTR > SIZE?
	JMS GET1	/NO. READ BLOCK.
	DCA THEFIB+BUFPOS /CLEAR OFFSET.
	TAD AC		/GET CURRENT BLOCK.
	DCA THEFIB+FILBLK /SAVE CURRENT BLOCK.

	JMP I	NXTBLK	/RETURN
/
	PAGE
	.SBTTL	OCHAR
/
/ 6	OCHAR Write one ASCII character at
/ 	      current file position.
/ AC	CHARACTER
/
/ ERROR:
/	AC	>=0	NO MORE SPACE
/	AC	<0	FATAL DEVICE ERROR
/
ICHAR,
OCHAR1,	0
	TAD	AC	/GET CHARACTER
	DCA	OCHAR	/SAVE IT.

	TAD	THEFIB+BUFPOS	/GET OFFSET.
	TAD	(-1000)		/CHECK IF END OF BLOCK REACHED.
	SZA CLA
	JMP	1$		/NO.
	JMS	NXTBLK	/YES. NEXT BLOCK.
	NOP

1$:	TAD	THEFIB+BUFPOS	/GET COUNT
	AND	(1774)
	CLL RAR
	TAD	THEFIB+BUFADR
	DCA	ARG		/THIS IS POINTER TO DOUBLEWORD CONTANING CHAR
	TAD	THEFIB+BUFFLD	/MAKE FIELD CHANGE CODE.
	TAD	(CDF)
	DCA	.+1
	HLT			/CHANGE FIELD.
	TAD	THEFIB+BUFPOS
	AND	(3)
	TAD	(-1)
	SNA		/0 = 2:ND CHAR...
	ISZ	ARG	/2:ND CHAR IS IN 2:ND WORD.
	SMA SZA CLA	/3:RD CHAR?
	JMP	OSPLIT	/3:RD...

	TAD I	ARG	/GET WORD.
	AND	(7400	/MASK CHAR.
	TAD	OCHAR	/PUT IN NEW CHAR.
	DCA I	ARG	/RESTORE.
OCRET,	CDF	.	/RESTORE FIELD.
	ISZ	THEFIB+BUFPOS	/BUMP POINTER.
	TAD	THEFIB+FILFLG	/SET BUFFER MODIFIED BIT.
	RAL
	CLL CML RAR
	DCA	THEFIB+FILFLG
	TAD	THEFIB+BUFPOS	/CHECK IF BUFFER IS FULL.
	TAD	(-1000)
	SZA CLA
	JMP	1$		/IS NOT.
	TAD	THEFIB+FILBLK	/IT IS. GET CURRENT BLOCK.
	DCA	AC
	JMS	PUT1		/OUTPUT CURRENT BLOCK

1$:	TAD	OCHAR		/GIVE OUTPUT CHARACTER BACK.
	DCA	AC
	JMP I	OCHAR1

OSPLIT,	CLA CLL CMA RAL	/REPEAT LOOP TWICE.
	DCA	LC
	TAD	OCHAR	/GET CHAR.
	RTL;RTL		/GET HIGH PART.
1$:	AND	(7400	/MASK.
	DCA	TMP	/SAVE IT.
	TAD I	ARG	/GET 1:ST WORD.
	AND	(377	/MASK AWAY PREVIOUS CHAR.
	TAD	TMP	/SAVE NEW CHAR.
	DCA I	ARG	/SAVE WORD.
	ISZ	ARG	/POINT AT NEXT WORD.
	TAD	OCHAR	/GET CHAR.
	RTR;RTR;RAR	/GET LOW PART
	ISZ	LC	/LOOP.
	JMP	1$
	CLA
	ISZ	THEFIB+BUFPOS
	JMP	OCRET	/CONTINUE.
	.SBTTL	ICHAR
/
/ 7	ICHAR Read next ASCII character
/
/ AC	The read character
/
/ ERROR:
/	AC	>=0	END OF FILE
/	AC	<0	FATAL DEVICE ERROR
OCHAR,
ICHAR1,	0
	TAD THEFIB+BUFPOS	/CHECK BUFFER COUNT.
	TAD (-1000)		/END?
	SZA CLA
	JMP 1$		/NO.
	JMS NXTBLK		/YES.
	JMP ERR1	/NO READ DONE. EOF.

1$:	TAD THEFIB+BUFPOS	/GET BUFFER COUNT.
	AND (1774)
	CLL RAR
	TAD THEFIB+BUFADR
	/ Save. First of two words of 3 chars.
	DCA ARG
	TAD THEFIB+BUFPOS
	AND (3)
	TAD (-1)
	SNA
	ISZ ARG
	SMA SZA CLA
	JMP ISPLIT	/ Go do third char
	TAD I ARG	/GET WORD.
	AND (377)	/ Mask 8 bit byte
PRET,	ISZ THEFIB+BUFPOS
	DCA AC	/SAVE CHAR.
	JMP I ICHAR1	/RETURN.

	/ Back up for 3rd of 3 chars.
ISPLIT,	TAD I ARG	/ High part in 1st word
	AND (7400	/MASK
	CLL RTR;RTR	/MOVE TO PLACE.
	DCA TMP		/SAVE.
	ISZ ARG
	TAD I ARG	/ Low part in 2nd word
	AND (7400	/MASK
	CLL RTL;RTL;RAL	/ Move thru link
	TAD TMP		/ Merge saved hi part
	ISZ THEFIB+BUFPOS
	JMP PRET	/CONTINUE.

	PAGE
	.SBTTL	POSIT
/ 11	POSIT
/
/ ARG	POINTER TO POSITION (24BIT)
/
/ ERROR:
/	AC	>=0	END OF FILE
/		<0	FATAL DEVICE ERROR
/
POSIT1,	0
	TAD I	ARG	/GET ADDRESS OF ARGUMENT.
	DCA	TMP
	TAD I	TMP	/GET BLOCK #.
	ISZ	TMP
	DCA	AC
	TAD I	TMP	/GET OFFSET.
	DCA	THEFIB+BUFPOS
	CDF	.
	JMS	GET1	/READ IN BLOCK.
	JMP I	POSIT1	/RETURN
	.SBTTL	POSITP
/
/ 12	POSITP
/
/ AC	RETURNED LOW PART OF POS.
/ ARG	POINTER TO ADDRESS FOR HIGH PART.
/
/	ERROR:
/	NONE

POSIP1,	0
	TAD I	ARG	/GET POINTER TO RESULT ADDRESS.
	DCA	TMP
	TAD	THEFIB+FILBLK	/GET BLOCK.
	DCA I	TMP
	ISZ	TMP
	TAD	THEFIB+BUFPOS	/GET OFFSET.
	DCA I	TMP
	CDF	.
	JMP I	POSIP1	/RETURN
	.SBTTL	CLOSE
/ 13	CLOSE
/
/ ERROR:
/	AC	>=0	NO MORE SPACE
/		<0	FATAL DEVICE ERROR

CLOSE1,	0
	TAD THEFIB+FILFLG	/GET FLAGS.
	SMA CLA		/MODIFIED BLOCK?
	JMP 1$		/NO.
	TAD THEFIB+FILBLK /YES. Write it
	DCA AC
	JMS PUT1

1$:	TAD THEFIB+FILFLG	/GET FLAGS.
	RAR
	SNL CLA		/ Tentative file?
	JMP ECLOS$	/ no

	TAD (THEFIB+FILNAM)
	DCA FNAM$	/ Filename ptr

	TAD THEFIB+FILSIZ
	DCA FSIZ$	/ Final size

	TAD THEFIB+DEVNUM	/ Dev #
	CIF 10
	JMS USR		/ USR CLOSE.
	4
FNAM$:	0	/ Pointer to name
FSIZ$:	0	/ Blocks in file
	JMP	ERR1

ECLOS$:	DCA THEFIB+FILFLG	/CLEAR FILE FLAGS.
	JMP I CLOSE1	/RETURN

	.SBTTL	FLUSH
/ 14	FLUSH
/
/ OUTPUT:
/	AC		BLOCK #
/
/ ERROR:
/	AC	>=0	NO MORE SPACE
/		<0	FATAL DEVICE ERROR
/
FLUSH1,	0		/ENTRY TO FLUSH.
	DCA AC	/CLEAR AC.
	TAD THEFIB+FILFLG / Was block modified?
	SMA CLA
	JMP I FLUSH1	/ No..

	/ Finish current packed word
PAD$:	TAD THEFIB+BUFPOS
	AND (3)		/GET BYTE OFFSET.
	SNA CLA		/OFFSET=0?
	JMP FILL$	/YES.
	JMS OCHAR1	/NO. OUTPUT A NUL.
	JMP PAD$	/REPEAT.

	/ Set up zeroing rest of block
FILL$:	TAD THEFIB+BUFPOS	/GET OFFSET.
	AND (1774)	/GET WORD OFFSET.
	CLL RAR
	DCA TMP		/SAVE OFFSET.
	TAD TMP
	TAD (-400) 	/GET COUNT.
	SNA
	JMP WRITE$	/ALREADY AT END OF BLOCK.
	DCA LC
	TAD TMP		/GET OFFSET.
	TAD THEFIB+BUFADR
	DCA TMP		/SAVE ADDRESS.
	TAD THEFIB+BUFFLD /GET BUFFER FIELD.
	TAD (CDF)
	DCA .+1
	HLT		/CHANGE FIELD.

	/ Fill rest of block with zeros
LOOP$:	DCA I TMP	/CLEAR WORD.
	ISZ TMP		/BUMP POINTER.
	ISZ LC		/BUMP COUNTER.
	JMP LOOP$	/LOOP.

WRITE$:	CDF .		/CHANGE FIELD BACK.
	TAD (1000)	/SET POINTER TO END OF BLOCK.
	DCA THEFIB+BUFPOS
	TAD THEFIB+FILBLK /GET CURRENT BLOCK #.
	DCA AC
	JMS PUT1	/OUTPUT CURRENT BLOCK #.
	JMP I FLUSH1
